# Boolean-returning expressions
false: a -> { 1 0 = () }
true: a -> { 1 1 = () }

# List definition
empty: visitor -> {}

cons: list -> value -> {
    visitor -> {
        value visitor ()
        visitor list ()
    }
}

# List helpers
reverse_list: list -> {
    empty

    value -> {
        list -> { list value cons () }
        ()
    }

    list ()
}

split_list: list -> {
    empty

    1 true ()

    value -> {
        first -> {
            new_list -> {
                new_list value cons ()
                1 false ()
            }

            new_list -> {
                value

                new_list
                1 false ()
            }

            first ? () ()
        }

        ()
    }

    list ()
    bool -> {} ()
}

list_empty: list -> {
    1 true ()

    value -> {
        result -> { 1 false () } ()
    }

    list ()
}

# Parse helpers
is_digit: c -> {
    c

    false

    c -> {
        c

        false

        true

        47 c > ()

        ? () ()
    }

    58 c < ()

    ? () ()
}

# Token constructors
number_token: number -> {
    visit_number -> visit_operator -> {
        number visit_number ()
    }
}

operator_token: operator -> {
    visit_number -> visit_operator -> {
        operator visit_operator ()
    }
}

token_plus: 0
token_minus: 1
token_times: 2

# Main parsing method
parse_input: {
    finish: 0
    peek: 1
    consume: 2

    # Number parsing mode:
    # Consumes characters until "not a digit" is received
    parse_number: tokens -> char -> number -> {
        check_digit: char -> {
            {
                tokens
                number number_token ()
                cons ()

                peek
                process_char
            }

            {
                tokens
                consume

                "0" char - ()
                number 10 * ()
                + ()

                number -> {
                    tokens -> char -> {
                        tokens char number parse_number ()
                    }
                }

                ()
            }

            char is_digit ()

            ? () ()
        }

        char check_digit ()
    }

    # Top-level parsing mode
    process_char: tokens -> char -> {
        # Final case, check if the parsing is done
        check_eof: char -> {
            {
                "Error: Unexpected '" ,,,,,,,,,,,,,,,,,,,
                char ,
                10 "'" ,,

                empty
                finish
                {}
            }

            {
                tokens
                finish
                {}
            }

            char 10 = ()

            ? () ()
        }

        # Check for the "*" operator
        check_times: char -> {
            {
                # TODO: Additional operators and parenthesis
                char check_eof ()
            }

            {
                tokens
                token_times operator_token ()
                cons ()

                consume
                process_char
            }

            char "*" = ()

            ? () ()
        }

        # Check for the "-" operator
        check_minus: char -> {
            {
                char check_times ()
            }

            {
                tokens
                token_minus operator_token ()
                cons ()

                consume
                process_char
            }

            char "-" = ()

            ? () ()
        }

        # Check for the "+" operator
        check_plus: char -> {
            {
                char check_minus ()
            }

            {
                tokens
                token_plus operator_token ()
                cons ()

                consume
                process_char
            }

            char "+" = ()

            ? () ()
        }

        # Check if we are about to parse a number
        check_digit: char -> {
            {
                char check_plus ()
            }

            {
                tokens
                consume

                "0" char - ()

                number -> {
                    tokens -> char -> {
                        tokens char number parse_number ()
                    }
                }

                ()
            }

            char is_digit ()

            ? () ()
        }

        # Skip any whitespace
        check_whitespace: char -> {
            {
                char check_digit ()
            }

            {
                tokens
                consume
                process_char
            }

            char " " = ()

            ? () ()
        }

        char check_whitespace ()
    }

    # Main input loop
    main_loop: tokens -> process -> {
        handle: tokens -> char -> process -> {
            tokens char process ()

            tokens -> result -> process -> {
                {
                    { tokens process main_loop () }
                    { tokens char process handle () }
                    peek result = ()
                    ? () ()
                }

                {
                    tokens
                }

                finish result = ()
                ? () ()
            }

            ()
        }

        tokens ~ process handle ()
    }

    empty process_char main_loop ()
}

# Parsed input execution method
execute_input: tokens -> {
    # Helper function to get the precedence for an operator
    operator_precedence: operator -> {
        {
            {
                { 0 }
                { 3 }
                operator token_times = ()

                ? () ()
            }

            { 2 }
            operator token_minus = ()

            ? () ()
        }

        { 2 }
        operator token_plus = ()

        ? () ()
    }

    # Helper function to get the builtin function to executa an operator
    operator_builtin: operator -> {
        {
            {
                { 0 }
                { * }
                operator token_times = ()

                ? () ()
            }

            { x -> y -> { y x - () } }
            operator token_minus = ()

            ? () ()
        }

        { + }
        operator token_plus = ()

        ? () ()
    }

    # Visitor for a numeric token that pushes it to the output stack
    number_visitor: number -> {
        # The operator stack is a list on top of the numbers on the actual stack,
        # so swap them
        operator_stack -> { number operator_stack } ()
    }

    # Visitor for an operator token
    operator_visitor: new_operator -> {
        # Grab the operator stack so we can play with it
        # The rest of the stack will be the numbers in our expression so far
        operator_stack -> {
            # Here, we need to recursively:
            #  - Check the precedence of the top of the stack
            #  - Fold down the top of the numeric stack if needed
            #  - If not needed, finish and push this new operator to the stack

            # Push a function for handling a non-empty operator stack
            {
                peek_loop: operator_stack -> {
                    operator_stack split_list ()

                    head -> rest -> {
                        {
                            head operator_builtin () ()
                            rest new_operator operator_visitor ()
                        }

                        {
                            rest head cons ()
                            new_operator cons ()
                        }

                        head operator_precedence ()
                        new_operator operator_precedence ()
                        > ()

                        ? () ()
                    }

                    ()
                }

                operator_stack peek_loop ()
            }

            # Push a function for handling an empty operator stack
            {
                # Simply push the new operator to the list!
                operator_stack new_operator cons ()
            }

            operator_stack list_empty ()

            ? () ()
        }

        ()
    }

    # Visit each token in our parsed expression
    list_visitor: token -> {
        number_visitor operator_visitor token ()
    }

    fold_operators: operators -> {
        operator -> {
            operator operator_builtin () ()
        }

        operators ()
    }

    empty
    list_visitor tokens ()
    fold_operators ()
}

parse_input ()
reverse_list ()
execute_input ()

.
